{% extends "layout/base.html" %}

{% block content %}
<div class="container mx-auto max-w-4xl p-4">
  <div class="flex justify-between items-center mb-6">
    <h1 class="text-2xl font-bold">Reading Practice</h1>
    {% if profile %}
    <div class="text-sm text-gray-600">
      Language: {{ profile.lang }} â†’ {{ profile.target_lang }}
    </div>
    {% endif %}
  </div>

  {% if is_demo %}
  <div class="bg-yellow-50 border border-yellow-200 rounded-lg p-4 mb-6">
    <p class="text-yellow-800">
      <span class="font-semibold">Demo Mode:</span>
      Text generation is not yet available. This is a placeholder text.
    </p>
  </div>
  {% endif %}

  <!-- Main reading content -->
  <div id="current-reading">
    <div class="bg-white rounded-lg shadow-md p-8">
      <!-- Reading text container -->
      <div
        id="reading-text"
        data-text-id="{{ text_id }}"
        data-account-id="{{ account_id }}"
        class="text-lg leading-relaxed"
      >
        <!-- Text will be rendered here with interactive word spans -->
      </div>

      <!-- Action buttons -->
      <div class="mt-8 pt-6 border-t flex justify-between items-center">
        <button
          id="translation-toggle"
          type="button"
          class="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-50"
          aria-expanded="false"
        >
          Show Translation
        </button>
        <button
          id="next-text-btn"
          type="button"
          class="px-6 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg"
        >
          Next Text
        </button>
      </div>
    </div>
  </div>

  <!-- Translation panel -->
  <div id="translation-panel" class="hidden mt-6 bg-white rounded-lg shadow-md p-6">
    <h2 class="text-lg font-bold mb-4">Translation</h2>
    <p id="translation-text" class="text-gray-700">
      {% if is_demo %}
      Hello! Welcome to your reading practice.
      This is a simple demo text to get you started.
      The full text generation system will be available soon.
      {% else %}
      Translation not yet available.
      {% endif %}
    </p>
  </div>
</div>

<!-- Word data and initial content -->
<script>
(function() {
  'use strict';

  // Word data passed from backend
  const wordData = {{ word_data | tojson }};
  const textContent = {{ text_content | tojson }};

  /**
   * Render text with interactive word spans
   * Words with available glosses become clickable with hover translations
   * Multi-segment words (e.g., German "ruf...an") have all segments linked
   */
  function renderInteractiveText() {
    const container = document.getElementById('reading-text');
    if (!container) return;

    // If no word data, just show plain text
    if (!wordData || wordData.length === 0) {
      container.innerHTML = `<p class="whitespace-pre-wrap">${escapeHtml(textContent)}</p>`;
      return;
    }

    // Expand word_data to handle multi-segment words
    const expandedWords = [];
    let wordIdCounter = 0;

    for (const word of wordData) {
      // Check if this is a multi-segment word
      const multiSpans = word.grammar?.spans;
      if (multiSpans && Array.isArray(multiSpans) && multiSpans.length > 1) {
        // Multi-segment word - create entry for each segment
        const sharedWordId = `word-${wordIdCounter++}`;
        for (const span of multiSpans) {
          expandedWords.push({
            ...word,
            span_start: span[0],
            span_end: span[1],
            word_id: sharedWordId,
            is_segment: true
          });
        }
      } else {
        // Single-segment word
        expandedWords.push({
          ...word,
          word_id: `word-${wordIdCounter++}`,
          is_segment: false
        });
      }
    }

    // Sort and validate spans
    const validWords = expandedWords
      .filter(word => {
        // Validate span positions
        const hasValidSpans = (
          word.span_start >= 0 &&
          word.span_end <= textContent.length &&
          word.span_start < word.span_end
        );

        // Validate that the span actually points to the expected word
        if (hasValidSpans) {
          const extractedText = textContent.substring(word.span_start, word.span_end);
          // For multi-segment words, be more lenient with matching
          const matches = (
            extractedText === word.surface ||
            extractedText.includes(word.surface) ||
            word.surface.includes(extractedText) ||
            word.is_segment  // Allow segments even if they don't perfectly match surface
          );
          return matches;
        }

        return false;
      })
      .sort((a, b) => a.span_start - b.span_start);

    if (validWords.length === 0) {
      console.warn('[Reading] No valid word spans found, showing plain text');
      container.innerHTML = `<p class="whitespace-pre-wrap">${escapeHtml(textContent)}</p>`;
      return;
    }

    let html = '';
    let lastPos = 0;

    for (const word of validWords) {
      // Add text before this word
      if (word.span_start > lastPos) {
        const beforeText = textContent.substring(lastPos, word.span_start);
        html += escapeHtml(beforeText);
      }

      // Extract the actual text at the span position
      const actualText = textContent.substring(word.span_start, word.span_end);

      // Add the interactive word span - store word data in a global array instead of HTML attribute
      const wordIndex = validWords.indexOf(word);
      html += `<span
        class="interactive-word cursor-pointer border-b border-dotted border-gray-400 hover:bg-blue-50 hover:border-blue-500 transition-colors"
        data-word-index="${wordIndex}"
        data-word-id="${word.word_id}"
        data-surface="${escapeHtml(word.surface)}"
        data-translation="${escapeHtml(word.translation || '')}"
      >${escapeHtml(actualText)}</span>`;

      lastPos = word.span_end;
    }

    // Add remaining text after last word
    if (lastPos < textContent.length) {
      html += escapeHtml(textContent.substring(lastPos));
    }

    // Wrap in paragraph and store word data globally
    container.innerHTML = `<p class="whitespace-pre-wrap">${html}</p>`;

    // Store word data globally for click handlers
    container.wordData = validWords;
  }

  /**
   * Escape HTML to prevent XSS
   */
  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  /**
   * Handle next text button with proper API call
   */
  function setupNextButton() {
    const nextBtn = document.getElementById('next-text-btn');
    if (!nextBtn) return;

    nextBtn.addEventListener('click', async function() {
      // Save session data before moving to next text
      if (window.saveSessionToServer) {
        await window.saveSessionToServer();
      }

      try {
        const response = await fetch('/reading/next', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          }
        });

        if (response.ok) {
          // Reload page to show next text
          window.location.reload();
        } else {
          console.error('Failed to get next text');
        }
      } catch (error) {
        console.error('Error:', error);
      }
    });
  }

  /**
   * Setup multi-segment word highlighting
   * When hovering one segment, all segments with the same word-id highlight
   */
  function setupMultiSegmentHighlighting() {
    const words = document.querySelectorAll('[data-word-id]');
    let hideTimeout = null;
    let isSticky = false; // When true, tooltip stays visible until clicked away

    words.forEach(word => {
      const wordId = word.getAttribute('data-word-id');

      word.addEventListener('mouseenter', function() {
        // Clear any pending hide
        if (hideTimeout) {
          clearTimeout(hideTimeout);
          hideTimeout = null;
        }

        // Highlight all segments with the same word-id
        document.querySelectorAll(`[data-word-id="${wordId}"]`).forEach(el => {
          el.classList.add('highlighted-segment');
        });
      });

      word.addEventListener('mouseleave', function() {
        // Remove highlight from all segments with the same word-id
        document.querySelectorAll(`[data-word-id="${wordId}"]`).forEach(el => {
          el.classList.remove('highlighted-segment');
        });

        // Hide tooltip after delay if in sticky mode
        if (isSticky) {
          const tooltip = document.getElementById('word-tooltip');
          if (tooltip && !tooltip.matches(':hover')) {
            hideTimeout = setTimeout(() => {
              tooltip.style.display = 'none';
              isSticky = false;
            }, 300);
          }
        }
      });

      // Click handler to show sticky tooltip and track interaction
      word.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();

        // Clear any pending hide
        if (hideTimeout) {
          clearTimeout(hideTimeout);
          hideTimeout = null;
        }

        // Show tooltip in sticky mode
        isSticky = true;
        showTooltipForWord(word, true);

        // Track word click for SRS/vocabulary system
        if (window.trackWordClick && container.wordData) {
          const wordIndex = parseInt(word.getAttribute('data-word-index'));
          const clickedWord = container.wordData[wordIndex];

          if (clickedWord) {
            window.trackWordClick({
              surface: clickedWord.surface,
              lemma: clickedWord.lemma,
              pos: clickedWord.pos,
              span_start: clickedWord.span_start,
              span_end: clickedWord.span_end,
              translation: clickedWord.translation
            });
          }
        }
      });
    });

    // Hide sticky tooltip when clicking outside
    document.addEventListener('click', function(e) {
      if (isSticky && !e.target.closest('[data-word-id]') && !e.target.closest('#word-tooltip')) {
        const tooltip = document.getElementById('word-tooltip');
        if (tooltip) {
          tooltip.style.display = 'none';
        }
        isSticky = false;
      }
    });

    // Also hide on ESC key
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape' && isSticky) {
        const tooltip = document.getElementById('word-tooltip');
        if (tooltip) {
          tooltip.style.display = 'none';
        }
        isSticky = false;
      }
    });
  }

  /**
   * Show translation tooltip for a word
   * @param {HTMLElement} wordElement - The word element
   * @param {boolean} sticky - If true, tooltip stays visible until clicked away
   */
  function showTooltipForWord(wordElement, sticky = false) {
    const container = document.getElementById('reading-text');
    if (!container || !container.wordData) return;

    const wordIndex = parseInt(wordElement.getAttribute('data-word-index'));
    const wordData = container.wordData[wordIndex];

    if (!wordData) return;

    // Create or get tooltip
    let tooltip = document.getElementById('word-tooltip');
    if (!tooltip) {
      tooltip = document.createElement('div');
      tooltip.id = 'word-tooltip';
      // Allow pointer events so tooltip can be hovered
      tooltip.className = 'absolute z-50 bg-white border border-gray-200 rounded-lg shadow-lg p-3 text-sm max-w-xs';
      document.body.appendChild(tooltip);
    }

    // Build tooltip content
    let content = `<div class="font-medium text-gray-900 mb-1">${escapeHtml(wordData.surface)}</div>`;

    // Add pronunciation (pinyin for Chinese, IPA for English, etc.) between word and translation
    if (wordData.pinyin) {
      content += `<div class="text-sm text-gray-600">${escapeHtml(wordData.pinyin)}</div>`;
    }

    if (wordData.translation) {
      content += `<div class="text-gray-700">${escapeHtml(wordData.translation)}</div>`;
    } else {
      content += `<div class="text-gray-500 italic">No translation available</div>`;
    }

    // Add lemma before form info
    if (wordData.lemma && wordData.lemma !== wordData.surface) {
      content += `<div class="text-xs text-gray-500 mt-1">Lemma: ${escapeHtml(wordData.lemma)}</div>`;
    }

    // Add part of speech
    if (wordData.pos) {
      const posDisplay = wordData.pos.replace(/_/g, ' ');
      content += `<div class="text-xs text-blue-600 mt-1 font-medium">${escapeHtml(posDisplay)}</div>`;
    }

    // Add grammar/word form info (gender, number, person, tense, mood, etc.)
    if (wordData.grammar && Object.keys(wordData.grammar).length > 0) {
      const grammar = wordData.grammar;
      const formParts = [];

      // Build form string from grammar features
      if (grammar.gender) {
        const genderMap = { 'm': 'masc', 'f': 'fem' };
        formParts.push(genderMap[grammar.gender] || grammar.gender);
      }
      if (grammar.number) {
        const numberMap = { 'sg': 'sing', 'pl': 'plur' };
        formParts.push(numberMap[grammar.number] || grammar.number);
      }
      if (grammar.person) {
        if (grammar.person === '1') formParts.push('1st');
        else if (grammar.person === '2') formParts.push('2nd');
        else if (grammar.person === '3') formParts.push('3rd');
        else formParts.push(grammar.person);
      }
      if (grammar.tense) {
        formParts.push(grammar.tense);
      }
      if (grammar.mood && grammar.mood !== 'indicative') {
        formParts.push(grammar.mood);
      }

      // Format as "3sg.pres.ind" style notation
      if (formParts.length > 0) {
        content += `<div class="text-xs text-purple-600 mt-0.5">${formParts.join('.')}</div>`;
      }
    }

    tooltip.innerHTML = content;
    tooltip.style.display = 'block';

    // Position tooltip near the word
    const rect = wordElement.getBoundingClientRect();
    const tooltipRect = tooltip.getBoundingClientRect();

    let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);
    let top = rect.top - tooltipRect.height - 8;

    // Keep tooltip in viewport
    if (left < 10) left = 10;
    if (left + tooltipRect.width > window.innerWidth - 10) {
      left = window.innerWidth - tooltipRect.width - 10;
    }
    if (top < 10) {
      top = rect.bottom + 8; // Show below instead
    }
    if (top + tooltipRect.height > window.innerHeight - 10) {
      top = window.innerHeight - tooltipRect.height - 10;
    }

    tooltip.style.left = left + 'px';
    tooltip.style.top = top + 'px';
  }

  // Initialize session tracking when text is loaded
  function initializeSessionTracking() {
    if (!window.ArcadiaReadingApp || !window.ArcadiaReadingApp.AppState) return;

    const readingText = document.getElementById('reading-text');
    if (!readingText) return;

    const textId = readingText.getAttribute('data-text-id');
    if (!textId) return;

    // Set app state
    window.ArcadiaReadingApp.AppState.currentTextId = parseInt(textId);
    window.ArcadiaReadingApp.AppState.accountId = parseInt(readingText.getAttribute('data-account-id'));

    // Initialize session data
    if (window.ArcadiaReadingApp.ReadingController) {
      window.ArcadiaReadingApp.ReadingController.initializeSessionData();
    }

    console.log('[Session] Initialized tracking for text', textId);
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      renderInteractiveText();
      setupNextButton();
      setupMultiSegmentHighlighting();
      initializeSessionTracking();
      // Re-attach app.js event handlers after rendering
      setTimeout(() => {
        if (window.ArcadiaReadingApp) {
          const readingText = document.getElementById('reading-text');
          if (readingText && window.ArcadiaReadingApp.ReadingController) {
            // Trigger re-attachment of handlers by dispatching custom event
            window.dispatchEvent(new Event('arcadia:words-rendered'));
          }
        }
      }, 50);
    });
  } else {
    renderInteractiveText();
    setupNextButton();
    setupMultiSegmentHighlighting();
    initializeSessionTracking();
    // Re-attach app.js event handlers after rendering
    setTimeout(() => {
      if (window.ArcadiaReadingApp) {
        const readingText = document.getElementById('reading-text');
        if (readingText && window.ArcadiaReadingApp.ReadingController) {
          // Trigger re-attachment of handlers by dispatching custom event
          window.dispatchEvent(new Event('arcadia:words-rendered'));
        }
      }
    }, 50);
  }
})();
</script>

<style>
.interactive-word {
  cursor: pointer;
  border-bottom: 1px dotted #9ca3af;
  transition: all 0.15s ease-in-out;
}

.interactive-word:hover {
  background-color: #eff6ff;
  border-bottom: 1px solid #3b82f6;
}

/* Multi-segment word highlighting - all segments highlight together */
.interactive-word.highlighted-segment {
  background-color: #dbeafe !important;
  border-bottom: 2px solid #3b82f6 !important;
  box-shadow: 0 2px 4px rgba(59, 130, 246, 0.1);
}

#word-tooltip {
  z-index: 1000;
  pointer-events: none;
}

#word-tooltip:hover {
  pointer-events: auto;
}
</style>
{% endblock %}
