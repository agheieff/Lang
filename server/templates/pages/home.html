{% extends "layout/base.html" %}

{% block content %}
<div class="container mx-auto max-w-4xl p-4">
  <h1 class="text-3xl font-bold mb-6">Language Practice</h1>

  {% if not has_profile %}
  <div class="bg-white rounded-lg shadow-md p-6 mb-6">
    <h2 class="text-xl font-bold mb-4">Get Started</h2>
    <p class="text-gray-600 mb-4">
      {% if is_authenticated %}
      Create a language profile to start practicing with automatically generated texts.
      {% else %}
      Create an account to start practicing with automatically generated texts.
      {% endif %}
    </p>
    <a href="{% if is_authenticated %}/profile{% else %}/signup{% endif %}"
       class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg transition-colors inline-block">
      {% if is_authenticated %}Create Profile{% else %}Sign Up{% endif %}
    </a>
  </div>
  {% else %}
  <div class="bg-white rounded-lg shadow-md p-6 mb-6">
    <h2 class="text-xl font-bold mb-4">Current Reading</h2>
    <div id="current-reading"
         class="border border-gray-200 rounded-lg p-4 bg-gray-50"
         hx-get="/reading/current"
         hx-trigger="load delay:200ms"
         hx-swap="innerHTML"
         hx-target="this"
         hx-select="unset"
         hx-disinherit="*"
         data-lang="{{ profile_lang or '' }}">
      <div class="animate-pulse space-y-3" aria-hidden="true">
        <div class="h-4 bg-gray-200 rounded w-3/4"></div>
        <div class="h-4 bg-gray-200 rounded w-5/6"></div>
        <div class="h-4 bg-gray-200 rounded w-2/3"></div>
        <div class="h-4 bg-gray-200 rounded w-4/5"></div>
      </div>
    </div>
    <script>
    (function(){
      async function initWordClicks(){
        const container = document.getElementById('current-reading');
        const textEl = container && container.querySelector('#reading-text');
        const titleEl = container && container.querySelector('#reading-title');
        if (!Array.isArray(container.__wordsStore)) container.__wordsStore = [];

        // Initialize unified session storage
        function initUnifiedSession(textId, titleWords, bodyWords, textContent, titleContent, targetLang) {
          const sessionId = Date.now() + '_' + Math.random().toString(36).substr(2, 9);
          const key = `arc_session_${textId}_${sessionId}`;
          
          // Helper to split text into sentences and paragraphs
          function splitIntoSentences(text) {
            if (!text) return [];
            const sentences = [];
            if (String(targetLang || '').startsWith('zh')) {
              const pattern = /[^。！？!?…]+(?:[。！？!?…]+|$)/;
              for (const match of text.matchAll(pattern)) {
                sentences.push(match[0].trim());
              }
            } else {
              const pattern = /[^.!?]+(?:[.!?]+|$)/;
              for (const match of text.matchAll(pattern)) {
                sentences.push(match[0].trim());
              }
            }
            return sentences.filter(s => s.length > 0);
          }
          
          function splitIntoParagraphs(text) {
            if (!text) return [];
            return text.split(/\n\s*\n/).filter(p => p.trim().length > 0);
          }
          
          // Build paragraph structure with sentences and words
          const paragraphs = [];
          const paragraphTexts = splitIntoParagraphs(textContent);
          
          let wordIndex = 0;
          for (const paraText of paragraphTexts) {
            const sentences = [];
            const sentenceTexts = splitIntoSentences(paraText);
            
            for (const sentenceText of sentenceTexts) {
              // Get words for this sentence (approximate)
              const sentenceWords = [];
              const wordsInSentence = sentenceText.split(/\s+/).length;
              for (let i = 0; i < wordsInSentence && wordIndex < bodyWords.length; i++) {
                sentenceWords.push({
                  surface: bodyWords[wordIndex].surface,
                  lemma: bodyWords[wordIndex].lemma,
                  pos: bodyWords[wordIndex].pos,
                  translation: bodyWords[wordIndex].translation,
                  looked_up_at: null
                });
                wordIndex++;
              }
              
              sentences.push({
                text: sentenceText,
                translation: null,
                translated_at: null,
                words: sentenceWords
              });
            }
            
            paragraphs.push({
              text: paraText,
              translation: null,
              translated_at: null,
              sentences: sentences
            });
          }
          
          const sessionData = {
            session_id: sessionId,
            text_id: Number(textId),
            lang: document.getElementById('current-reading')?.dataset.lang || 'es',
            target_lang: targetLang || 'en',
            opened_at: Date.now(),
            title: {
              text: titleContent || '',
              full_translation: null,
              translated_at: null,
              words: (titleWords || []).map(w => ({
                surface: w.surface,
                lemma: w.lemma,
                pos: w.pos,
                translation: w.translation,
                span_start: w.span_start,
                span_end: w.span_end,
                looked_up_at: null
              }))
            },
            full_text: textContent,
            full_translation: null,
            paragraphs: paragraphs,
            // Flat words list for simpler extraction (works better for Chinese)
            words: (bodyWords || []).map(w => ({
              surface: w.surface,
              lemma: w.lemma,
              pos: w.pos,
              translation: w.translation,
              span_start: w.span_start,
              span_end: w.span_end,
              looked_up_at: null
            })),
            analytics: {
              total_words: bodyWords ? bodyWords.length : 0,
              words_looked_up: 0,
              lookup_rate: 0,
              reading_time_ms: 0,
              average_reading_speed_wpm: 0,
              completion_status: 'in_progress'
            }
          };
          
          try { 
            localStorage.setItem(key, JSON.stringify(sessionData));
            // Store current session key for easy access
            localStorage.setItem(`arc_current_session_${textId}`, key);
          } catch {}
          return sessionId;
        }

      // Initialize title words (clickable via fallback substring scan)
        if (titleEl && titleEl.dataset.titleWordsInit !== '1'){
          titleEl.dataset.titleWordsInit = '1';
          const tw = getEmbeddedTitleWords();
          if (Array.isArray(tw) && tw.length) {
            makeClickable(titleEl, tw);
            attachTooltip(titleEl, tw);
          }
        }

        // Initialize body text words as before
        if (!textEl) return;
        const textId = textEl.dataset.textId;
        if (!textId) return;
        if (textEl.dataset.wordsInit === '1') return;
        textEl.dataset.wordsInit = '1';
        if (textEl.querySelector('[data-word-index]')) return;
        const embedded = getEmbeddedWords();
        let words = Array.isArray(embedded) ? embedded : [];
        if (words && words.length) {
          makeClickable(textEl, words);
          attachTooltip(textEl, words);
          // Initialize unified session storage
          try {
            const titleEl = container && container.querySelector('#reading-title');
            const titleText = titleEl ? titleEl.textContent.trim() : '';
            const titleWords = getEmbeddedTitleWords() || [];
            const textContent = textEl.textContent || '';
            initUnifiedSession(textId, titleWords, words, textContent, titleText, 'en');
          } catch(err) {}
        }
      }

      // Expose entry points for (re)initializing and updating a freshly
      // rendered reading block so other scripts can call them.
      window.arcInitReadingBlock = function(){
        try { initWordClicks(); } catch (_e) {}
        try { initSentenceTranslations(); } catch (_e) {}
      };

      window.arcApplyWords = function(words){
        try {
          const container = document.getElementById('current-reading');
          const textEl = container && container.querySelector('#reading-text');
          if (!textEl || !Array.isArray(words) || !words.length) return;
          makeClickable(textEl, words);
          attachTooltip(textEl, words);
          // Also initialize session storage so words are tracked for SRS
          const textId = textEl.dataset.textId;
          if (textId) {
            const titleEl = container && container.querySelector('#reading-title');
            const titleText = titleEl ? titleEl.textContent.trim() : '';
            const titleWords = getEmbeddedTitleWords() || [];
            const textContent = textEl.textContent || '';
            initUnifiedSession(textId, titleWords, words, textContent, titleText, 'en');
          }
        } catch (_e) {}
      };

      async function initSentenceTranslations(){
        const textEl = document.getElementById('reading-text');
        if (!textEl) return;
        const textId = textEl.dataset && textEl.dataset.textId ? Number(textEl.dataset.textId) : 0;
        if (!textId) return;
        if (textEl.dataset.trInit === '1') return;
        textEl.dataset.trInit = '1';
        function normalize(s){ return String(s||'').replace(/[\s\u00A0]+/g,' ').trim(); }
        function readSentenceCacheAny(){
          try{
            for(let i=0;i<localStorage.length;i++){
              const k = localStorage.key(i) || '';
              if(k.startsWith(`arc_rtt_${textId}_`) && k.endsWith('_sentence')){
                try{ const v = JSON.parse(localStorage.getItem(k) || 'null'); if(v && Array.isArray(v.items)) return { key: k, data: v }; }catch{}
              }
            }
          }catch{}
          return null;
        }
        function buildSentenceOffsets(plainText, items){
          if(window.arcReadingUtils && window.arcReadingUtils.buildSentenceOffsets){
            return window.arcReadingUtils.buildSentenceOffsets(plainText, items);
          }
          return [];
        }
        function deriveAndStoreCaches(data){
          try{
            const sessionKey = localStorage.getItem(`arc_current_session_${textId}`);
            if (!sessionKey) return;
            
            const sessionData = JSON.parse(localStorage.getItem(sessionKey) || '{}');
            const tgt = (data && typeof data.target_lang === 'string' && data.target_lang) ? data.target_lang : 'en';
            const translationTime = Date.now();
            
            // Update sentence translations in unified session
            if (Array.isArray(data.items)) {
              const textEl2 = document.getElementById('reading-text');
              const plain = (window.arcReadingUtils && window.arcReadingUtils.serializePlainText)
                ? window.arcReadingUtils.serializePlainText(textEl)
                : (textEl.textContent || '');
              const mapping = buildSentenceOffsets(plain, data.items);
              
              // Update paragraph and sentence translations in session data
              if (sessionData.paragraphs) {
                let sentenceIndex = 0;
                for (const paragraph of sessionData.paragraphs) {
                  if (!paragraph.sentences) continue;
                  for (const sentence of paragraph.sentences) {
                    if (sentenceIndex < data.items.length && mapping[sentenceIndex] && mapping[sentenceIndex].item) {
                      sentence.translation = mapping[sentenceIndex].item.translation;
                      sentence.translated_at = translationTime;
                    }
                    sentenceIndex++;
                  }
                }
              }
              
              // Update full translation for the text
              sessionData.full_translation = data.items.map(it => String(it.translation || '')).join(' ');

              try { localStorage.setItem(sessionKey, JSON.stringify(sessionData)); } catch {}

              // If the bottom translation panel exists, keep it in sync
              try {
                const full = (sessionData.full_translation || '').trim();
                if (full) {
                  const panelTextEl = document.getElementById('translation-text');
                  if (panelTextEl) {
                    panelTextEl.textContent = full;
                  }
                }
              } catch (_e) {}
            }

            // Restore: build and cache paragraph/text translations alongside sentences
            const textEl2 = document.getElementById('reading-text');
            if(textEl2){
              const plain = (window.arcReadingUtils && window.arcReadingUtils.serializePlainText)
                ? window.arcReadingUtils.serializePlainText(textEl)
                : (textEl.textContent || '');
              const mapping = buildSentenceOffsets(plain, Array.isArray(data.items)?data.items:[]);
              // Paragraphs split by blank line
              const paras = []; let i=0, n=plain.length;
              while(i < n){ let s=i; while(s<n && plain[s]==='\n') s++; if(s>=n) break; let e=s; while(e<n-1 && !(plain[e]==='\n' && plain[e+1]==='\n')) e++; while(e<n && plain[e]!== '\n') e++; paras.push({start:s,end:Math.min(n,e)}); i=e; }
              const pItems = [];
              for(const p of paras){
                const parts = [];
                for(const m of mapping){ if(m.start==null||m.end==null) continue; if(m.start>=p.end) break; if(m.end<=p.start) continue; if(m.item && m.item.translation) parts.push(String(m.item.translation)); }
                const src = String(plain.slice(p.start, p.end));
                pItems.push({ start: p.start, end: p.end, source: src, translation: parts.join(' ') });
              }
              const pData = { unit: 'paragraph', target_lang: tgt, items: pItems };
              const pKey = `arc_rtt_${textId}_${tgt}_paragraph`;
              try{ localStorage.setItem(pKey, JSON.stringify(pData)); }catch{}
              const tData = { unit: 'text', target_lang: tgt, items: [{ translation: (Array.isArray(data.items)?data.items:[]).map(it=>String(it.translation||'')).join(' ') }] };
              const tKey = `arc_rtt_${textId}_${tgt}_text`;
              try{ localStorage.setItem(tKey, JSON.stringify(tData)); }catch{}
            }
          }catch{}
        }
        try{
          const res = await fetch(`/reading/${textId}/translations?unit=sentence&wait=25`, { headers: { 'Accept': 'application/json' } });
          if (!res.ok) return;
          const data = await res.json();
          if (!data || !Array.isArray(data.items)) return;
          deriveAndStoreCaches(data);
        }catch{}
      }
      // SSE path will fetch and apply words when ready; no local polling.
      function getEmbeddedWords(){
        const el = document.getElementById('reading-words-json');
        if (!el) return null;
        try { return JSON.parse(el.textContent || '[]'); } catch { return null; }
      }
      function getEmbeddedTitleWords(){
        const el = document.getElementById('reading-title-words-json');
        if (!el) return null;
        try { return JSON.parse(el.textContent || '[]'); } catch { return null; }
      }
      // Build plain text from DOM where <br> counts as a single "\n" and existing [data-word-index] spans are treated as atomic
      function serializePlainText(root){
        if(window.arcReadingUtils && window.arcReadingUtils.serializePlainText){
          return window.arcReadingUtils.serializePlainText(root);
        }
        return (root && root.textContent) ? root.textContent : '';
      }
      // Use backend-provided span offsets when available to avoid drift
      function ensureStore(){
        const container = document.getElementById('current-reading');
        if (!Array.isArray(container.__wordsStore)) container.__wordsStore = [];
        if (!container.__wordCounter) container.__wordCounter = 0;
        return container;
      }
      // Try a small local correction if the substring at [s,e] doesn't equal the surface
      function _maybeAdjustSpan(root, s, e, surface){
        try{
          if(typeof s !== 'number' || typeof e !== 'number') return null;
          if(!surface || !surface.length) return null;
          const plain = serializePlainText(root);
          const want = String(surface);
          if(plain.slice(s, e) === want) return { s, e };
          const maxShift = 4;
          for(let d=-maxShift; d<=maxShift; d++){
            const s2 = s + d; const e2 = s2 + want.length;
            if(s2 < 0 || e2 > plain.length) continue;
            if(plain.slice(s2, e2) === want){ return { s: s2, e: e2 }; }
          }
        }catch{}
        return null;
      }
      function wrapBySpans(textEl, words){
        const container = ensureStore();
        let added = 0;
        if (!Array.isArray(words)) return 0;
        for (let wi = 0; wi < words.length; wi++){
          const w = words[wi];
          if (!Number.isInteger(w.span_start) || !Number.isInteger(w.span_end)) continue;
          let s = Number(w.span_start), e = Number(w.span_end);
          if (s<0 || e<=s) continue;
          if (textEl.querySelector(`[data-span-start="${s}"][data-span-end="${e}"]`)) continue;
          // Small window correction to account for rare offset drift (e.g., ±2 chars)
          try{
            const adj = _maybeAdjustSpan(textEl, s, e, w.surface);
            if(adj && (adj.s !== s || adj.e !== e)){
              // Skip if an adjusted wrapper already exists
              if(textEl.querySelector(`[data-span-start="${adj.s}"][data-span-end="${adj.e}"]`)){
                continue;
              }
              s = adj.s; e = adj.e;
            }
          }catch{}
          const startPos = _resolveDomPosAt(textEl, s);
          const endPos = _resolveDomPosAt(textEl, e);
          if (!startPos || !endPos) continue;
          try{
            const range = document.createRange();
            range.setStart(startPos.node, startPos.offset);
            range.setEnd(endPos.node, endPos.offset);
            const wrapper = document.createElement('span');
            _styleWordSpan(wrapper, container.__wordCounter, !!(document.getElementById('current-reading')?.dataset.lang||'').toLowerCase().startsWith('zh'));
            wrapper.dataset.wordIndex = String(container.__wordCounter);
            wrapper.dataset.spanStart = String(s);
            wrapper.dataset.spanEnd = String(e);
            const frag = range.extractContents();
            wrapper.appendChild(frag);
            range.insertNode(wrapper);
            // Store for tooltip lookup
            container.__wordsStore.push(w);
            container.__wordCounter += 1;
            added += 1;
          }catch{}
        }
        return added;
      }
      function makeClickable(textEl, words){
        const container = document.getElementById('current-reading');
        const isZh = !!(container && (container.dataset.lang || '').toLowerCase().startsWith('zh'));
        const spansExist = Array.isArray(words) && words.some(w => Number.isInteger(w.span_start) && Number.isInteger(w.span_end));

        // First pass: wrap by exact spans for items that have them (in-order)
        if (spansExist) {
          wrapBySpans(textEl, words);
        }

        // Fallback: naive substring scan within text nodes (less reliable)
        // Only for words without backend-provided spans to avoid duplicate wrapping and drift
        const missing = Array.isArray(words) ? words.filter(w => !(Number.isInteger(w.span_start) && Number.isInteger(w.span_end))) : [];
        let mi = 0;
        const walker = document.createTreeWalker(
          textEl,
          NodeFilter.SHOW_TEXT,
          {
            acceptNode(node){
              if (!node.nodeValue || !node.nodeValue.trim()) return NodeFilter.FILTER_REJECT;
              const p = node.parentElement;
              if (p && p.closest('[data-word-index]')) return NodeFilter.FILTER_REJECT;
              return NodeFilter.FILTER_ACCEPT;
            }
          }
        );
        while (mi < missing.length && walker.nextNode()) {
          let node = walker.currentNode;
          let text = node.nodeValue || '';
          let pos = 0;
          while (mi < missing.length) {
            const form = (missing[mi].surface || '').toString();
            if (!form) { mi++; continue; }
            const idx = text.indexOf(form, pos);
            if (idx === -1) break;
            if (idx > 0) { node = node.splitText(idx); text = node.nodeValue || ''; }
            const after = node.splitText(form.length);
            const span = document.createElement('span');
            const container2 = ensureStore();
            _styleWordSpan(span, container2.__wordCounter, isZh);
            span.dataset.wordIndex = String(container2.__wordCounter);
            span.textContent = form;
            node.parentNode.replaceChild(span, node);
            // push fallback word object for tooltip minimal info
            container2.__wordsStore.push(missing[mi]);
            container2.__wordCounter += 1;
            node = after; text = after.nodeValue || ''; pos = 0; mi++;
          }
        }
      }

      function _styleWordSpan(span, wi, isZh){
        // Apply classes; CSS below handles underline rendering
        if (isZh) {
          span.className = 'word-span word-span--zh';
        } else {
          span.className = 'word-span';
        }
      }

      // Map a character offset (in the plain text where <br> counts as "\n") to a DOM Text node and offset
      function _resolveDomPosAt(root, charIndex){
        let idx = 0;
        function walk(node){
          if (!node) return null;
          if (node.nodeType === Node.TEXT_NODE) {
            const len = (node.nodeValue || '').length;
            if (charIndex <= idx + len) {
              return { node: node, offset: Math.max(0, charIndex - idx) };
            }
            idx += len;
            return null;
          }
          if (node.nodeType === Node.ELEMENT_NODE) {
            const el = node;
            if (el.hasAttribute && el.hasAttribute('data-word-index')) {
              // Treat wrapped span as atomic text: advance idx by its length and continue scanning siblings
              const len = (el.textContent || '').length;
              idx += len;
              return null;
            }
            // Treat <br> as a single "\n" character in the plain text stream
            if (el.tagName === 'BR') { idx += 1; return null; }
            for (let child = el.firstChild; child; child = child.nextSibling) {
              const res = walk(child);
              if (res) return res;
            }
          }
          return null;
        }
        return walk(root);
      }
      function attachTooltip(textEl, words){
        const tooltip = document.getElementById('word-tooltip');
        if (!tooltip) return;
        
        // Prevent duplicate event listeners
        if (textEl.dataset.tooltipAttached === '1') return;
        textEl.dataset.tooltipAttached = '1';
        
        // Ensure tooltip is initially hidden
        tooltip.classList.add('hidden');
        function render(w){
          const parts = [];
          if (w.surface) parts.push(`<div class="font-semibold">${escapeHtml(w.surface)}</div>`);
          if (w.pinyin) parts.push(`<div class="text-gray-600">${escapeHtml(w.pinyin)}</div>`);
          if (w.lemma) parts.push(`<div class="text-gray-600">Lemma: ${escapeHtml(w.lemma)}</div>`);
          if (w.translation) parts.push(`<div class="mt-1">${escapeHtml(w.translation)}</div>`);
          if (w.pos) parts.push(`<div class="mt-1 text-xs text-gray-500">${escapeHtml(w.pos)}</div>`);
          if (w.grammar && typeof w.grammar === 'object' && Object.keys(w.grammar).length > 0) {
            try { parts.push(`<pre class="mt-1 bg-gray-50 p-2 rounded">${escapeHtml(JSON.stringify(w.grammar, null, 2))}</pre>`); } catch {}
          }
          return parts.join('');
        }
        function positionTooltip(target){
          const rect = target.getBoundingClientRect();
          tooltip.style.left = `${rect.left + window.scrollX}px`;
          tooltip.style.top = `${rect.bottom + window.scrollY + 8}px`;
        }
        textEl.addEventListener('click', (e) => {
          const t = e.target;
          if (!(t instanceof Element)) return;
          const idx = t.getAttribute('data-word-index');
          if (idx == null) return;
          
          // Stop propagation to prevent the global click handler from immediately hiding it
          e.stopPropagation();
          
          console.log('Word clicked, idx:', idx);
          
          const container = document.getElementById('current-reading');
          const store = (container && Array.isArray(container.__wordsStore)) ? container.__wordsStore : words;
          console.log('Store length:', store.length, 'Store sample:', store && store.length ? store.slice(0, 3) : 'undefined');
          const w = store[Number(idx)];
          console.log('Found word:', w);
          if (!w) return;
          try {
            // Update unified session with word lookup
            try {
              const textEl2 = document.getElementById('reading-text');
              const tid = textEl2 && textEl2.dataset ? String(textEl2.dataset.textId||'') : '';
              if (tid) {
                const sessionKey = localStorage.getItem(`arc_current_session_${tid}`);
                if (sessionKey) {
                  const sessionData = JSON.parse(localStorage.getItem(sessionKey) || '{}');
                  const lookupTime = Date.now();
                  
                  // Update title word if it's a title word
                  const container = document.getElementById('current-reading');
                  const titleEl = container && container.querySelector('#reading-title');
                  const isTitleWord = titleEl && titleEl.contains(t);
                  
                  if (isTitleWord && sessionData.title && sessionData.title.words) {
                    const titleWord = sessionData.title.words.find(tw => tw.surface === w.surface);
                    if (titleWord) {
                      titleWord.looked_up_at = lookupTime;
                    }
                  }
                  
                  // Update flat words array (primary path for SRS tracking)
                  if (sessionData.words) {
                    const flatWord = sessionData.words.find(fw => fw.surface === w.surface && !fw.looked_up_at);
                    if (flatWord) {
                      flatWord.looked_up_at = lookupTime;
                      sessionData.analytics.words_looked_up = (sessionData.analytics.words_looked_up || 0) + 1;
                      sessionData.analytics.lookup_rate = sessionData.analytics.words_looked_up / sessionData.analytics.total_words;
                    }
                  }
                  
                  // Also update paragraphs structure for backwards compatibility
                  if (sessionData.paragraphs) {
                    for (const para of sessionData.paragraphs) {
                      if (para.sentences) {
                        for (const sentence of para.sentences) {
                          if (sentence.words) {
                            const sentenceWord = sentence.words.find(sw => sw.surface === w.surface);
                            if (sentenceWord && !sentenceWord.looked_up_at) {
                              sentenceWord.looked_up_at = lookupTime;
                              break;
                            }
                          }
                        }
                      }
                    }
                  }
                  
                  console.log('Updated session data:', sessionData);
                  try { localStorage.setItem(sessionKey, JSON.stringify(sessionData)); } catch {}
                }
              }
            } catch {}
          } catch {}
          tooltip.innerHTML = render(w);
          tooltip.classList.remove('hidden');
          console.log('Showing tooltip, classes:', tooltip.className);
          positionTooltip(t);
        });
        
        // Use a separate function for the global click handler
        function handleGlobalClick(e) {
          const el = e.target;
          // Check if click is on tooltip or on a word span
          if (tooltip.contains(el) || (textEl.contains(el) && el.getAttribute && el.getAttribute('data-word-index') != null)) {
            console.log('Click on tooltip or word, not hiding');
            return;
          }
          console.log('Global click hiding tooltip');
          tooltip.classList.add('hidden');
          console.log('Hiding tooltip, classes:', tooltip.className);
        }
        
        // Remove any existing global click listener to prevent duplicates
        document.removeEventListener('click', handleGlobalClick);
        document.addEventListener('click', handleGlobalClick);
        function escapeHtml(s){
          return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
        }
      }
      function maybeInit(ev){
        if (ev && ev.detail && ev.detail.elt && ev.detail.elt.id === 'current-reading') {
          if (window.arcInitReadingBlock) window.arcInitReadingBlock();
        }
      }
      document.addEventListener('htmx:afterSwap', maybeInit);
      document.addEventListener('htmx:afterSettle', maybeInit);
    })();
    </script>
    <style>
      /* Generic clickable word */
      .word-span {
        cursor: pointer;
        text-decoration: underline;
        text-underline-offset: 2px;
      }
      /* Chinese: render a solid underline with a tiny trailing gap */
      .word-span--zh {
        text-decoration: none;        /* disable default underline */
        position: relative;
        /* solid underline using background so we can stop early */
        background-image: linear-gradient(currentColor, currentColor);
        background-repeat: no-repeat;
        background-position: 0 100%;
        /* leave a small gap (2px) at the end to show boundary */
        background-size: calc(100% - var(--gap, 2px)) 1.5px;
      }
      .word-span:hover {
        background-color: rgba(0,0,0,0.04);
      }
    </style>
  </div>
  {% endif %}

  {% if is_authenticated %}
  <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
    <div class="bg-white rounded-lg shadow-md p-4">
      <h3 class="text-lg font-bold mb-2">Your Words</h3>
      <p class="text-sm text-gray-600 mb-4">
        Review and manage your vocabulary
      </p>
      <a href="/words" class="border border-gray-300 hover:bg-gray-50 px-3 py-1 rounded-lg text-sm transition-colors">View Words</a>
    </div>

    <div class="bg-white rounded-lg shadow-md p-4">
      <h3 class="text-lg font-bold mb-2">Progress Stats</h3>
      <p class="text-sm text-gray-600 mb-4">
        Track your learning progress
      </p>
      <a href="/stats" class="border border-gray-300 hover:bg-gray-50 px-3 py-1 rounded-lg text-sm transition-colors">View Stats</a>
    </div>
  </div>
  {% endif %}
</div>

{% endblock %}