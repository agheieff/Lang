{% extends "layout/base.html" %}

{% block content %}
<div class="container mx-auto max-w-4xl p-4">
  <h1 class="text-3xl font-bold mb-6">Language Practice</h1>

  {% if not has_profile %}
  <div class="bg-white rounded-lg shadow-md p-6 mb-6">
    <h2 class="text-xl font-bold mb-4">Get Started</h2>
    <p class="text-gray-600 mb-4">
      {% if is_authenticated %}
      Create a language profile to start practicing with automatically generated texts.
      {% else %}
      Create an account to start practicing with automatically generated texts.
      {% endif %}
    </p>
    <a href="{% if is_authenticated %}/profile{% else %}/signup{% endif %}"
       class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg transition-colors inline-block">
      {% if is_authenticated %}Create Profile{% else %}Sign Up{% endif %}
    </a>
  </div>
  {% else %}
  <div class="bg-white rounded-lg shadow-md p-6 mb-6">
    <h2 class="text-xl font-bold mb-4">Current Reading</h2>
    <div id="current-reading"
         class="border border-gray-200 rounded-lg p-4 bg-gray-50"
         hx-get="/reading/current"
         hx-trigger="load delay:200ms"
         hx-swap="innerHTML"
         hx-target="#current-reading"
         hx-disinherit="*"
         hx-select="*"
         data-lang="{{ profile_lang or '' }}">
      <div class="animate-pulse space-y-3" aria-hidden="true">
        <div class="h-4 bg-gray-200 rounded w-3/4"></div>
        <div class="h-4 bg-gray-200 rounded w-5/6"></div>
        <div class="h-4 bg-gray-200 rounded w-2/3"></div>
        <div class="h-4 bg-gray-200 rounded w-4/5"></div>
      </div>
    </div>
    <script>
    (function(){
      async function initWordClicks(){
        const container = document.getElementById('current-reading');
        const textEl = container && container.querySelector('#reading-text');
        if (!textEl) return;
        const textId = textEl.dataset.textId;
        if (!textId) return;
        if (textEl.querySelector('[data-word-index]')) return;
        const embedded = getEmbeddedWords();
        let words = Array.isArray(embedded) ? embedded : [];
        if (words && words.length) {
          makeClickable(textEl, words);
          attachTooltip(textEl, words);
        } else {
          // Long-poll for words (single request held server-side until available or timeout)
          try {
            const res = await fetch(`/reading/${Number(textId)}/words?wait=25`, { headers: { 'Accept': 'application/json' } });
            if (res.ok) {
              const data = await res.json();
              const ws = (data && Array.isArray(data.words)) ? data.words : [];
              if (ws.length) {
                makeClickable(textEl, ws);
                attachTooltip(textEl, ws);
              } else {
                // Auto-retry until words arrive (best-effort)
                if (!textEl.dataset.wordsPolling) {
                  textEl.dataset.wordsPolling = '1';
                  pollWords(textEl, Number(textId));
                }
              }
            }
          } catch {}
        }
      }
      async function pollWords(textEl, textId){
        if (!textEl || !textId) return;
        if (textEl.querySelector('[data-word-index]')) return; // already clickable
        try {
          const res = await fetch(`/reading/${Number(textId)}/words?wait=25`, { headers: { 'Accept': 'application/json' } });
          if (res.ok) {
            const data = await res.json();
            const ws = (data && Array.isArray(data.words)) ? data.words : [];
            if (ws.length) {
              makeClickable(textEl, ws);
              attachTooltip(textEl, ws);
              return;
            }
          }
        } catch {}
        setTimeout(() => pollWords(textEl, textId), 2000);
      }
      function getEmbeddedWords(){
        const el = document.getElementById('reading-words-json');
        if (!el) return null;
        try { return JSON.parse(el.textContent || '[]'); } catch { return null; }
      }
      // SSE removed: long-poll request is used instead
      function makeClickable(textEl, words){
        const container = document.getElementById('current-reading');
        const isZh = !!(container && (container.dataset.lang || '').toLowerCase().startsWith('zh'));
        let wi = 0;
        const walker = document.createTreeWalker(
          textEl,
          NodeFilter.SHOW_TEXT,
          {
            acceptNode(node){
              if (!node.nodeValue || !node.nodeValue.trim()) return NodeFilter.FILTER_REJECT;
              const p = node.parentElement;
              if (p && p.closest('[data-word-index]')) return NodeFilter.FILTER_REJECT;
              return NodeFilter.FILTER_ACCEPT;
            }
          }
        );
        while (wi < words.length && walker.nextNode()) {
          let node = walker.currentNode;
          let text = node.nodeValue || '';
          let pos = 0;
          while (wi < words.length) {
            const w = (words[wi].surface || '').toString();
            if (!w) { wi++; continue; }
            const idx = text.indexOf(w, pos);
            if (idx === -1) break;
            if (idx > 0) {
              node = node.splitText(idx);
              text = node.nodeValue || '';
            }
            const after = node.splitText(w.length);
            const span = document.createElement('span');
            // Styling: make word boundaries visible for Chinese by alternating underline styles/colors
            if (isZh) {
              span.className = 'cursor-pointer';
              span.style.textDecoration = 'underline';
              span.style.textDecorationThickness = '2px';
              span.style.textUnderlineOffset = '2px';
              // Alternate color/style per word index to make boundaries clear
              if ((wi % 2) === 0) {
                span.style.textDecorationStyle = 'solid';
                span.style.textDecorationColor = '#6b7280'; /* gray-500 */
              } else {
                span.style.textDecorationStyle = 'dashed';
                span.style.textDecorationColor = '#9ca3af'; /* gray-400 */
              }
            } else {
              span.className = 'cursor-pointer underline decoration-dotted';
              span.style.textDecorationThickness = '2px';
              span.style.textUnderlineOffset = '2px';
            }
            span.dataset.wordIndex = String(wi);
            span.textContent = w;
            node.parentNode.replaceChild(span, node);
            node = after;
            text = after.nodeValue || '';
            pos = 0;
            wi++;
          }
        }
      }
      function attachTooltip(textEl, words){
        const tooltip = document.getElementById('word-tooltip');
        if (!tooltip) return;
        function render(w){
          const parts = [];
          if (w.surface) parts.push(`<div class="font-semibold">${escapeHtml(w.surface)}</div>`);
          if (w.pinyin) parts.push(`<div class="text-gray-600">${escapeHtml(w.pinyin)}</div>`);
          if (w.lemma) parts.push(`<div class="text-gray-600">Lemma: ${escapeHtml(w.lemma)}</div>`);
          if (w.pos) parts.push(`<div class="text-gray-600">POS: ${escapeHtml(w.pos)}</div>`);
          if (w.translation) parts.push(`<div class="mt-1">${escapeHtml(w.translation)}</div>`);
          if (w.grammar && typeof w.grammar === 'object') {
            try { parts.push(`<pre class="mt-1 bg-gray-50 p-2 rounded">${escapeHtml(JSON.stringify(w.grammar, null, 2))}</pre>`); } catch {}
          }
          return parts.join('');
        }
        function positionTooltip(target){
          const rect = target.getBoundingClientRect();
          tooltip.style.left = `${rect.left + window.scrollX}px`;
          tooltip.style.top = `${rect.bottom + window.scrollY + 8}px`;
        }
        textEl.addEventListener('click', (e) => {
          const t = e.target;
          if (!(t instanceof Element)) return;
          const idx = t.getAttribute('data-word-index');
          if (idx == null) return;
          const w = words[Number(idx)];
          if (!w) return;
          tooltip.innerHTML = render(w);
          tooltip.classList.remove('hidden');
          positionTooltip(t);
        });
        document.addEventListener('click', (e) => {
          const el = e.target;
          if (tooltip.contains(el) || (textEl.contains(el) && el.getAttribute && el.getAttribute('data-word-index') != null)) return;
          tooltip.classList.add('hidden');
        });
        function escapeHtml(s){
          return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
        }
      }
      function maybeInit(ev){
        if (ev && ev.detail && ev.detail.elt && ev.detail.elt.id === 'current-reading') {
          initWordClicks();
        }
      }
      document.addEventListener('htmx:afterSwap', maybeInit);
      document.addEventListener('htmx:afterSettle', maybeInit);
    })();
    </script>
  </div>
  {% endif %}

  {% if is_authenticated %}
  <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
    <div class="bg-white rounded-lg shadow-md p-4">
      <h3 class="text-lg font-bold mb-2">Your Words</h3>
      <p class="text-sm text-gray-600 mb-4">
        Review and manage your vocabulary
      </p>
      <a href="/words" class="border border-gray-300 hover:bg-gray-50 px-3 py-1 rounded-lg text-sm transition-colors">View Words</a>
    </div>

    <div class="bg-white rounded-lg shadow-md p-4">
      <h3 class="text-lg font-bold mb-2">Progress Stats</h3>
      <p class="text-sm text-gray-600 mb-4">
        Track your learning progress
      </p>
      <a href="/stats" class="border border-gray-300 hover:bg-gray-50 px-3 py-1 rounded-lg text-sm transition-colors">View Stats</a>
    </div>
  </div>
  {% endif %}
</div>
{% endblock %}